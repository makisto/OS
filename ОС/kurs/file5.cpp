#include <iostream>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
using namespace std;

LPBYTE OpenPEFile(LPCTSTR lpszFileName) {
  HANDLE hFile = CreateFile(lpszFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
  if (hFile == INVALID_HANDLE_VALUE)
    return NULL;
  HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
  CloseHandle(hFile);
  LPBYTE pBase = NULL;
  if (hMapping != NULL) {
    pBase = (LPBYTE)MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(hMapping);
  }
  return pBase;
}

void ClosePEFile(LPBYTE pBase) {
  if (pBase != NULL)
    UnmapViewOfFile(pBase);
}

IMAGE_NT_HEADERS* GetHeader(LPBYTE pBase) {
  // ???????? ???????????? ??????????.
  if (pBase == NULL)
    return NULL;
  // ???????? ????????? ?? ????????? DOS.
  IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)pBase;
  // ????????? ???????????? ?????????.
  if (IsBadReadPtr(pDosHeader, sizeof(IMAGE_DOS_HEADER)))
    return NULL;
  // ??????? ????????? ????????? DOS.
  if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE)
    return NULL;
  // ????? ????????? ?? ????????? PE.
  IMAGE_NT_HEADERS* pHeader = (IMAGE_NT_HEADERS*)(pBase + pDosHeader->e_lfanew);
  // ????????? ???????????? ?????????.
  if (IsBadReadPtr(pHeader, sizeof(IMAGE_NT_HEADERS)))
    return NULL;
  // ??????? ????????? ????????? PE.
  if (pHeader->Signature != IMAGE_NT_SIGNATURE)
    return NULL;
  return pHeader;
}

IMAGE_SECTION_HEADER* GetSection(IMAGE_NT_HEADERS* pHeader, DWORD dwRVA) 
{
  // ???????? ???????????? ??????????.
  if (pHeader == NULL)
    return NULL;
  // ??????? ???? ?????????? ??????.
  IMAGE_SECTION_HEADER* pSectHeader = IMAGE_FIRST_SECTION(pHeader);
  for (UINT i = 0; i < pHeader->FileHeader.NumberOfSections; i++, pSectHeader++) {
    // ???? RVA ????????? ?????? ??????, ?? ?????????? ????????? ?? ?? ?????????.
    if (dwRVA >= pSectHeader->VirtualAddress && dwRVA < pSectHeader->VirtualAddress + pSectHeader->Misc.VirtualSize)
      return pSectHeader;
  }
  return NULL; // ?????? ?? ???????
}

LPBYTE GetFilePointer(LPBYTE pBase, DWORD dwRVA) {
  // ???????? ???????????? ??????????.
  if (pBase == NULL)
    return NULL;
  // ???? ??????, ?????????? ?????? RVA.
  IMAGE_SECTION_HEADER* pSectHeader = GetSection(GetHeader(pBase), dwRVA);
  if (pSectHeader == NULL) // ???? ?????? ?? ???????,
    return pBase + dwRVA; // ?? RVA ????? ???????? ? ?????,
  // ????? ????????? ???????? ???????????? ?????? ?????? ? ?????.
  return pBase + pSectHeader->PointerToRawData + (dwRVA - pSectHeader->VirtualAddress);
}

void main(int argc, char* argv[]) 
{
  LPBYTE pBase = OpenPEFile("c:\\windows\\system32\\notepad.exe");
  if (pBase == NULL)
   {
    cout << "File not found!" << endl;
    return;
  }
  IMAGE_NT_HEADERS* pHeader = GetHeader(pBase);
  if (pHeader == NULL) 
  {
    cout << "It is not a PE file!" << endl;
    return;
  }
  cout << "Dir\tRVA\tSize\tFilePtr" << endl;
  IMAGE_DATA_DIRECTORY* pDataDir = pHeader->OptionalHeader.DataDirectory;
  for (UINT i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++, pDataDir++) 
  {
    if (pDataDir->Size != 0) 
	{
      ULONG nFilePtr = (ULONG)(ULONG_PTR)GetFilePointer(pBase, pDataDir->VirtualAddress);
      cout << dec << i << ":\t" << hex << pDataDir->VirtualAddress << '\t'
        << pDataDir->Size << '\t' << nFilePtr << endl;
    }
  }
  ClosePEFile(pBase);
}
